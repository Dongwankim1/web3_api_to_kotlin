/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.p2p.solanaj.core.Account
import org.p2p.solanaj.core.PublicKey
import org.p2p.solanaj.core.Transaction
import org.p2p.solanaj.programs.AssociatedTokenProgram
import org.p2p.solanaj.programs.SystemProgram
import org.p2p.solanaj.programs.TokenProgram
import org.p2p.solanaj.rpc.RpcClient
import java.math.BigInteger

fun main() {
    println("qfqwfqwf")
    val rpcEndpoint = "https://api.devnet.solana.com"
    val publicKey = "8ixPw2F1J2g724nkYeZtg4fEFrWTRf2Tna965rbwsVoD"
    val userPublicKey = "CZtRsFZ9oRNjU1tiS5PrETT8aEQTVAnA4FKCRPVdWWJe"
    val noTokenUserPublicKey = "98HNCdVFAddLntayXeRz68JV49RX1TgqSRYT5mRf6QCu"
    val mint = "E3iTukHHrabJ1f3mW8rKRZV6Y4PKMzoLD1HmN8gNGpgt"
    val secretKey = "digital drink present man hamster leave orbit scorpion tackle cheese chat cabbage"
    val solanaService = SolanaService()


    println(solanaService.getBalance(rpcEndpoint, userPublicKey))

    // solanaService.splTokenBalance(rpcEndpoint, secretKey, userPublicKey, mint)
    solanaService.splTokenBalance(rpcEndpoint, secretKey, noTokenUserPublicKey, mint)
}


class SolanaService {

    val associatedTokenProgramId = PublicKey("ATokenGPv1c2trTcbGnQ4WJNe48CwKM9DRJ8DRprz9x")
    val ACCOUNT_LAYOUT_SIZE:Long = 165L

    private fun getConnection(rpcEndpoint: String): RpcClient {
        return RpcClient(rpcEndpoint)
    }

    fun testConnection(rpcEndpoint: String): String {
        val client = getConnection(rpcEndpoint)
        return try {
            val version = client.api.getVersion() // Test API call
            "Connected to Solana RPC: $version"
        } catch (e: Exception) {
            "Failed to connect to Solana RPC: ${e.message}"
        }
    }

    fun getBalance(rpcEndpoint: String, publicKey: String): Double {
        println("getBalance")
        val connection = getConnection(rpcEndpoint)
        return try {
            val lamports = connection.api.getBalance(PublicKey(publicKey))
            lamports.toDouble() / LAMPORTS_PER_SOL
        } catch (e: Exception) {
            println("Error fetching balance: ${e.message}")
            0.0
        }
    }

    /**
     * 현재 토큰 밸런스 가져오기
     * @param rpcEndpoint String 솔라나 주소
     * @param secretKey String 민팅 owner 시크릿키
     * @param userPublicKey String 조회할 사용자 지갑주소
     * @param mint String 민팅 주소
     * @return Double
     */
    fun splTokenBalance(
        rpcEndpoint: String,
        secretKey: String,
        userPublicKey: String,
        mint: String
    ): BigInteger {

        val connection = getConnection(rpcEndpoint)

        val mintAddress = PublicKey(mint)

        // val secretByteArray = Base58.encode(secretKey.toByteArray());
        val secretKeypair = Account(secretKey.toByteArray())

        // Select the correct program ID and lamports conversion based on the environment
        return try {
            // Find or create the associated token account
            val tokenAccount = getOrCreateAssociatedTokenAccount(
                connection,
                secretKeypair,
                mintAddress,
                PublicKey(userPublicKey),
                false,
                "comfirmd",
                TokenProgram.PROGRAM_ID
            )
            println("tokenAccount  " + tokenAccount)
            return tokenAccount.second
        } catch (e: Exception) {
            println("Error fetching SPL token balance: ${e.message}")
            return BigInteger.valueOf(0L)
        }
        //     // Get the token balance
        //     val balanceResponse = connection.api.getTokenAccountBalance(tokenAccount.publicKey)
        //     val tokenAmount = balanceResponse?.value?.uiAmount ?: 0.0

        //     tokenAmount / lamportsSol
        // } catch (e: Exception) {
        //     println("Error fetching SPL token balance: ${e.message}")
        //     0.0
        // }
    }

    fun getOrCreateAssociatedTokenAccount(
        connection: RpcClient,
        payer: Account,
        mint: PublicKey,
        owner: PublicKey,
        allowOwnerOffCurve: Boolean = false,
        commitment: String = "confirmed",
        programId: PublicKey = TokenProgram.PROGRAM_ID
    ): Pair<PublicKey, BigInteger> {

        // Calculate the associated token account (ATA) address
        val associatedTokenAddress = PublicKey.findProgramAddress(
            listOf(
                owner.toByteArray(),
                TokenProgram.PROGRAM_ID.toByteArray(),
                mint.toByteArray()
            ),
            AssociatedTokenProgram.PROGRAM_ID
        )
        println("associatedTokenAddress : " + associatedTokenAddress.address)
        // Check if the ATA exists
        val accountInfo = connection.api.getAccountInfo(associatedTokenAddress.address)
        println("accountInfo = " + accountInfo);
        if (accountInfo.value != null) {
            // Fetch balance if ATA exists
            val tokenBalance = connection.api.getTokenAccountBalance(associatedTokenAddress.address)
            return Pair(associatedTokenAddress.address, BigInteger(tokenBalance.amount))

        }

        // If ATA doesn't exist, create it
        val transaction = Transaction()
        // val rentExemption = connection.api.getMinimumBalanceForRentExemption(165)
        // transaction.addInstruction(
        //     TokenProgram.createAssociatedTokenAccount(
        //         payer.publicKey, // 생성 비용을 지불하는 계정
        //         owner,           // 새 토큰 계정의 소유자
        //         mint             // 관리할 Mint 주소
        //     )
        // )
        val lamportsRequired: Long = connection.getApi().getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT_SIZE)
        // 새 토큰 계정
        // 새 토큰 계정
        val tokenAccount: Keypair = Keypair.generate()
        val tokenAccountPublicKey: PublicKey = tokenAccount.getPublicKey()
// SPL 토큰 계정 생성
        transaction.addInstruction(
            SystemProgram.createAccount(
                payer.publicKey,  // 계정 생성 비용을 지불할 계정
                tokenAccountPublicKey,  // 새로 생성할 SPL 토큰 계정
                lamportsRequired,  // 계정 생성에 필요한 Lamports
                ACCOUNT_LAYOUT_SIZE,  // SPL 토큰 계정의 공간
                TokenProgram.PROGRAM_ID // SPL 토큰 프로그램 ID
            )
        )

        transaction.addInstruction(
            TokenProgram.initializeAccount(
                associatedTokenAddress.address,
                mint,
                owner
            )
        )
        val signature: String = connection.getApi().sendTransaction(transaction, payer)
        // connection.api.sendTransaction(transaction, payer)
        print("associatedTokenAddress.address" + associatedTokenAddress.address)
        print("signature = " +signature)
        return Pair(associatedTokenAddress.address, BigInteger.ZERO)
    }

    companion object {
        private const val LAMPORTS_PER_SOL = 1_000_000_000 // 1 SOL = 1 billion lamports
    }

    fun isValidBase58(input: String): Boolean {
        val base58Pattern = Regex("^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+\$")
        return base58Pattern.matches(input)
    }

}