/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.bitcoinj.core.Base58
import org.bouncycastle.crypto.params.Ed25519PrivateKeyParameters
import org.p2p.solanaj.core.Account
import org.p2p.solanaj.core.PublicKey
import org.p2p.solanaj.core.Transaction
import org.p2p.solanaj.programs.AssociatedTokenProgram
import org.p2p.solanaj.programs.TokenProgram
import org.p2p.solanaj.rpc.RpcClient
import org.p2p.solanaj.rpc.RpcException
import org.web3j.crypto.MnemonicUtils
import java.math.BigInteger

fun main() {
    println("qfqwfqwf")
    val rpcEndpoint = "https://api.devnet.solana.com"
    val publicKey = "8ixPw2F1J2g724nkYeZtg4fEFrWTRf2Tna965rbwsVoD"
    val userPublicKey = "CZtRsFZ9oRNjU1tiS5PrETT8aEQTVAnA4FKCRPVdWWJe"
    val noTokenUserPublicKey = "98HNCdVFAddLntayXeRz68JV49RX1TgqSRYT5mRf6QCu"
    val mint = "E3iTukHHrabJ1f3mW8rKRZV6Y4PKMzoLD1HmN8gNGpgt"
    val secretKey = "digital drink present man hamster leave orbit scorpion tackle cheese chat cabbage"
    val solanaService = SolanaModule()


    println(solanaService.getBalance(noTokenUserPublicKey))

    solanaService.splTokenBalance(secretKey, noTokenUserPublicKey, mint)
    //solanaService.splTokenBalance(secretKey, userPublicKey, mint)

    //토큰 전송테스트
    val dto = SolanaModule.SplTokenTransferDto(
        secretKey,
        noTokenUserPublicKey,
        mint,
        BigInteger.valueOf(5000L)
    )

    //solanaService.splTokenTransfer(dto)

}


class SolanaModule {
    val rpcEndpoint = "https://api.devnet.solana.com"
    val associatedTokenProgramId = PublicKey("ATokenGPv1c2trTcbGnQ4WJNe48CwKM9DRJ8DRprz9x")
    val ACCOUNT_LAYOUT_SIZE:Long = 165L
    val connection: RpcClient

    init {
        connection = getConnection(rpcEndpoint)
    }
    private fun getConnection(rpcEndpoint: String): RpcClient {
        return RpcClient(rpcEndpoint)
    }

    fun getBalance(publicKey: String): Double {
        println("getBalance")

        return try {
            val lamports = this.connection.api.getBalance(PublicKey(publicKey))
            lamports.toDouble() / LAMPORTS_PER_SOL
        } catch (e: Exception) {
            println("Error fetching balance: ${e.message}")
            0.0
        }
    }

    /**
     * 현재 토큰 밸런스 가져오기
     * @param secretKey String - 민팅 owner 시크릿키 (payer)
     * @param userPublicKey String - 조회할 사용자 지갑주소
     * @param mint String - 민팅 주소
     * @return Double
     */
    fun splTokenBalance(
        secretKey: String,
        userPublicKey: String,
        mint: String
    ): BigInteger {

        val mintAddress = PublicKey(mint)


        // 3. 공개 키 생성
        val generateSolanaAccount = generateSolanaAccount(secretKey, "")

        // Select the correct program ID and lamports conversion based on the environment
        return try {
            // Find or create the associated token account
            val tokenAccount = getOrCreateAssociatedTokenAccount(
                generateSolanaAccount,
                mintAddress,
                PublicKey(userPublicKey),
                false,
                "comfirmd",
                TokenProgram.PROGRAM_ID
            )


            val amount = if(tokenAccount.second.compareTo(BigInteger.valueOf(0L))>=0){
                tokenAccount.second.divide(BigInteger.valueOf(LAMPORTS_PER_SOL));
            } else {
                BigInteger.valueOf(0L)
            }
            println("tokenAccount.second  " + amount)
            return amount
        } catch (e: Exception) {
            println("Error fetching SPL token balance: ${e.message}")
            return BigInteger.valueOf(0L)
        }

    }

    fun splTokenTransfer(request: SplTokenTransferDto): Transaction {
        if (request.amount  < BigInteger.valueOf(0L)) {
            throw IllegalArgumentException("Negative numbers are not allowed.")
        }

        // Decode the secret key and create an Account
        val senderKeypair = generateSolanaAccount(request.secretKey)

        // Fetch balance of the SPL Token account
        val balance = try {
            splTokenBalance(
                request.secretKey,
                senderKeypair.publicKey.toBase58(),
                request.mint
            )
        } catch (e: RpcException) {
            throw IllegalStateException("Error fetching SPL token balance: ${e.message}", e)
        }

        println("Balance: $balance")
        println("Request amount: ${request.amount}")

        if (balance < request.amount) {
            throw IllegalArgumentException("Insufficient balance")
        }

        // Create the transaction
        val transaction = Transaction()
        val mintAddress = PublicKey(request.mint)
        val senderAccount = getOrCreateAssociatedTokenAccount(
            senderKeypair,
            mintAddress,
            senderKeypair.publicKey,
            false,
            "comfirmd",
            TokenProgram.PROGRAM_ID
        )


        val recipientAccount = getOrCreateAssociatedTokenAccount(
            senderKeypair,
            mintAddress,
            PublicKey(request.recipient),
            false,
            "comfirmd",
            TokenProgram.PROGRAM_ID
        )

        // Add instruction to transfer SPL tokens
        // val transferInstruction = TokenProgram.transfer(
        //     mintAddress,
        //     tokenAccount.first,
        //     request.amount.toLong(),
        //     senderKeypair.publicKey,
        // )

        val transferInstruction = TokenProgram.transferChecked(
            senderAccount.first,
            recipientAccount.first,
            request.amount.multiply(BigInteger.valueOf(LAMPORTS_PER_SOL)).toLong(),
            9,
            senderKeypair.publicKey,
            mintAddress
        )

        transaction.addInstruction(transferInstruction)

        // Sign and send the transaction
        val signature: String = try {
            this.connection.api.sendTransaction(transaction, senderKeypair)
        } catch (e: RpcException) {
            throw IllegalStateException("Transaction failed: ${e.message}", e)
        }

        println("Transaction Signature: $signature")

        return transaction
    }

    // DTO class for request data
    data class SplTokenTransferDto(
        val secretKey: String,
        val recipient: String,
        val mint: String,
        val amount: BigInteger
    )

    /**
     *
     * @param payer Account - 지불 계정
     * @param mint PublicKey - 민트 주소
     * @param owner PublicKey - 토큰 오너 주소
     * @param allowOwnerOffCurve Boolean
     * @param commitment String
     * @param programId PublicKey
     * @return Pair<PublicKey, BigInteger>
     */
    fun getOrCreateAssociatedTokenAccount(
        payer: Account,
        mint: PublicKey,
        owner: PublicKey,
        allowOwnerOffCurve: Boolean = false,
        commitment: String = "confirmed",
        programId: PublicKey = TokenProgram.PROGRAM_ID
    ): Pair<PublicKey, BigInteger> {

        // Calculate the associated token account (ATA) address
        val associatedTokenAddress = PublicKey.findProgramAddress(
            listOf(
                owner.toByteArray(),
                TokenProgram.PROGRAM_ID.toByteArray(),
                mint.toByteArray()
            ),
            AssociatedTokenProgram.PROGRAM_ID
        )
        println("associatedTokenAddress : " + associatedTokenAddress.address)
        // Check if the ATA exists
        val accountInfo = this.connection.api.getAccountInfo(associatedTokenAddress.address)
        println("accountInfo = " + accountInfo);
        if (accountInfo.value != null) {
            // Fetch balance if ATA exists
            val tokenBalance = this.connection.api.getTokenAccountBalance(associatedTokenAddress.address)
            return Pair(associatedTokenAddress.address, BigInteger(tokenBalance.amount))

        }

        // If ATA doesn't exist, create it
        val transaction = Transaction()
        val create = AssociatedTokenProgram.createIdempotent(payer.publicKey, owner, mint)
        transaction.addInstruction(
            create
        )
        try {
            val signature: String = this.connection.api.sendTransaction(transaction, payer)

        }catch (e: RpcException){
            println(e.message)
        }

        return Pair(associatedTokenAddress.address, BigInteger.ZERO)
    }

    companion object {
        private const val LAMPORTS_PER_SOL = 1_000_000_000L // 1 SOL = 1 billion lamports
    }


    private fun generateSolanaAccount(mnemonic: String, passphrase: String = ""): Account {

        val seed = MnemonicUtils.generateSeed(mnemonic, "")

        // 2. Ed25519 비밀 키 생성 (상위 32바이트)
        val privateKey = seed.copyOf(32)
        val privateKeyParams = Ed25519PrivateKeyParameters(privateKey, 0)

        // 3. 공개 키 생성
        val publicKey = privateKeyParams.generatePublicKey().encoded

        // 4. Solana Account 생성
        return Account(privateKey + publicKey)
    }

}